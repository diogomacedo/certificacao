


Estudos para a Certificação Java SE 7 Programmer I [ 1Z0-803 ]


##################################################################################
##################################################################################

16/01/2017: tipos de dados - declarar e inicializar variáveis

	* Tipada: tipo das variáveis explícitos
	
	OBS: no Java 8 tem o tipo implícito, mas não cai na certificação do Java 7
	
	* Declaração-> tipo nome;
		--> int idade;

	[ VARIÁVEIS LOCAIS ]
		
	* Variáveis locais não têm valor padrão
	
	* Variáveis precisam ter um valor atribuído antes de poder ser utilizada
		--> Dá erro de compilação caso uma variável local não seja inicializada e esteja sendo utilizada;
		
	OBS.: variável local é aquela declarada dentro de um block ( método, construtor)
	
	[ VARIÁVEL MEMBRO ]
	
	* Variáveis memnbro tem valor padrão/inicial
	
		--> O valor padrão dos tipos numéricos é 0;
		--> Os CHARS são no fundo, no fundo numéricos no java. O valor padrão dele é 0, porém não é impresso;
		--> O valor padrão de um boolean é false;
		--> O valor padrão de referências ( objetos ) é null;
		
	OBS.: Valores padrão são aplicáveis somente a variáveis membro, variáveis de instância, variáveis atributo...
	
	[ ARRAY ]
	
	* Os vetores tem o valor padrão compatívels com seus tipos
		--> int[] valores = new int[10];
			--> cada posição terá o valor padrão 0;
	
	[ Tipos primitivos ]

	byte
	short
	char
	int
	long
	float
	double
	
	OBS.: todos os tipos primitivos são considerados numéricos, exceto o boolean;
	
	OBS.: o float e o double são os tipos com ponto flutuante;
	
	OBS.: o byte, short, int, long e char são numéricos do tipo inteiro
	
	OBS.: não existe no java tipos unsigned ou signed, ou seja, valores que ou são só positivos ou são só negativos; todos os tipos numéricos podem ser positivos e negativos;
	
	OBS.: não  é preciso decorar o tamanho dos tipos, exceto o do byte. O byte pode ter valores entre [ -128 ] e [ +127 ]
	
	OBS.: o char é o único tipo que só possui valores positivos ou 0 ( zero ), ou seja, seu valores são de [ 0 ] em diante...
	
	OBS.: short e char tem os mesmos tamanhos, porém char é só positivo, enquanto short pode ser de XXXX negativo até YYYY positivo;
	
	OBS.: variaveis´ flutuantes ( float e double ) podem assumir os seguitnes valores especiais:
		--> [ + infinto ] ou [  - infinito ]
		--> [ +0 ] ou [-0]
		--> NaN [ lê-se: not a number ] ( número inválido )
		
	[ NÚMEROS LITERAIS ]
	
	* Somente tipos primitivos podem ter valores literais
		--> int = 1590;
	
	* boolean
		-> [false] e [true] são valores literais do tipo boolean
		-> [ false ] e [ true ] precisam sempre estar em letras minúsculas
			--> OBS.: todas as palavras reservadas são minúsculas
	
	* números inteiros
		--> são considerados por padrão um int
		--> ex: int x = 15;
	
	* números com ponto flutuante ( casa decimal )
		--> são considerados por padrão dopuble
		--> ex: double v=10.2;
	
	* É possível forçar o tipo adicionando uma letra no final
		--> ex: long l = 13 ou long l = 13L ou long l = 13l;
		--> float f = 13.1f ou float f = 13.1F;
		--> double v = 10.2d ou double v = 10.2D;
	
	* É possível atribuir valores na base octal para inteiros
		--> ex: int i = 0791;
		--> int i = 010 [ número 8 na base decimal ]
		--> não precisa fazer conversão de bases, só precisa saber os tipos e tipo, não existe o número 08 na base octal pq os caracteres são de 0 a 7 [ 0, 1 , 2 , 3, 4 , 5, 6, 7]
	
	* É possível também atribuir valores hexadecimais para inteiros
		--> vai de 0 a 9 e A a F [ 0, 1, 2, 3, 4, 5, 6, 7, 8,3 9, A, B, C, D, E, F ]
		--> int i = 0xA [ número 11 na base decimal]
		--> não importa se o x é maiúsculo ou minusculo [ 0x ou 0X ] pq ambos são válidos
		
	* É possível também atribuir valores na base binária
		--> Inicia com 0b ou 0B
		--> ex: 0b01
		--> ex: 0b1000
	
	* É possível representar ponto flutuante com representação cientifica
		DOUBLE
		--> ex: 3.1E2 = 3.1x10² = 3.1x100 = 310;
		
		FLOAT
		--> ex: 2e3f = 2x10³ = 2x1000 = 2000;
	
	* Separação de grupos decimais
		--> a partir da versão 7 é possível utilizar o _ para representar o separador de grupos.
		--> ex: não se pode escrever --> long x2 = 1.234.567.891l
				mas, pode-se --> long x2 = 1_234_567_891l
		--> o [_] precisa estar entre números ou [_]
			ex: _1_234_567_891 -> erro de compilação pq não tem valor antes do primeiro _
		--> O _ pode vir do lado de outro _
			ex: 1__234_567__896l
			     0B1_00 [ pode ]
				 0_b100 [ não pode ]
				 0xF_F [ pode pq F tem valor de número ]
				 0x_FF [ não pode ]
		 
	* Não há equivalência entre o número e a letro na tabela unico
		ex: char letra = 'A';  --> imprime 'A'
			char letra = 65; --> imprime 'A';
			char sete = 7; --> imprime vazio;
		
		OBS.: Letra C > letra A
			  Letras maiúsculas são maiores que as letras minúsculas
			  
	
		--> se quiser atribuir um caracteres unicode é possível
			ex: char xx = '\u03A9';
			
		
	[ identificadores ]
	
	* são os nomes das variáveis, métodos, contrutores, classes, interfaces, pacotes...
	
	* Não é possível utilizar palavras reservadas
		ex: boolean, public, class, static, void
		OBS.: main pode ser utilizado
		
	* Não é possível utilizar valores literais ( true, false, null )
	
	* É possível utilizar caracteres unicode ( números, letras, caracteres especiais, $ e _ )
		--> é possível usar: bonitão, peça, botinao04444$$, boni_to;
		--> não pode: cas#tigo; [ cerquilha '#' não pode ser utilizado ]
	
	* O primeiro caractere não pode ser um número [ pode ser qualquer coisa, menos número ] ;
	
	* É case sensitive
		ex: int idade;
			int Idade;
			int iDAde;
	
17/01/2017: tipos de dados - diferenças entre variaveis de referência a objetos e tipos primitivos

	* Variáveis primitivas possuem um valor
		--> A operação de atribuição em variáveis do tipo primitivo faz uma cópia do valor
			int a = 10;
			int b = a;
			* Aqui tanto [a] quanto [b] têm o valor 10
			* É efetuada uma cópia do valor, ou seja, alterar [a] não alterará o valor de [b] e vice-versa
	
	* Variáveis de referência para objetos
		--> A operação de atribuição em variaveis de referência cria uma nova referência
			OBS.: Para criar um novo objeto é preciso usar o construtor
			Objeto o1 = new Objeto(); [ criado um novo objeto ]
			o1.valor = 10;
			Objeto o2 = o1; [ a variável de referência aponta para o mesmo objeto que o1 ]
			o1.valor+=15; [ somando o1 + 15 ]
			System.out.println(o1.valor); [ imprime 25 ]
			System.out.println(o2.valor); [ imprime 25 porque o2 referencia o mesmo objeto que o1 ]
			Objeto o3 = new Objeto(); [ aqui está sendo criado um novo objeto ]
	
17/01/2017: tipos de dados - lendo ou escrevendo campos de objetos

	[ como acessar variaveis membro , chamada normalmente de campos ]

	* É possível acessar variáveis membros/estância diretamente dentro de um construtor, método. Para isso, basta escrever o nome delas

		Ex: Class Carro {
			String modelo;
			int ano;
			Carro() {
				ano=2014;
			}
			void resetar() {
				ano=2014;
			}
		}
	
	* É possível também utilizar a palavra reservadas [this] para acessar um membro da classe
	
		Ex: Carro(){
				this.ano=2014;
			}

	* A palavra reservada [this] num método significa [a instância atual] e num construtor significa [o objeto que está sendo construído]
	
	* Em um método que não possua um parâmetro ( variável local ) com o mesmo nome da variável membro ( atributo ), o this é opcional . Exemplos acima.
	
	* O [ this ] se torna obrigatório em um construtor / método quando existe um parâmetro com o mesmo nome do atributo da classe.
	
		Ex: Carro(int ano) {
			this.ano = ano;
		}
		void configurar(int ano) {
			this.ano = ano;
		}
		void resetar() {
			ano = 2014;
		}

	OBS.: Caso um modificador de acesso não seja atribuído a um membro de uma classe ( variável, método, construtor ), esse item é acessível a partir da referencia;
	
		Ex: Class Teste {
			Carro carro = new Carro();
			carro.ano=2017;
			carro.configurar(2020);
		}
		
17/01/2017: tipos de dados - o ciclo de vida de um objeto

	* Quando é criado um objeto ?
	* Quando um objeto deixa de ser referenciado da memória?
	* Quando o objeto vai embora da memória ?
	
	* Um objeto é criado quando o construtor da classe é chamado
	* Um objeto é criado quando é utilizado a palavra reservada [new]
	
	* Um objeto é acessível enquanto ele é referenciado por uma variável diretamente ou indiretamente;
	
	* Um objeto é inacessível quando não houver mais referências diretas ou indiretas
	
	* Um objeto pode ser excluído da memória pelo garbage collector ( GC ) a qualquer instante a partir do momento que ele se tornou inacessível
	
	* Por padrão, na especificação, não tem como saber quando o GC vai rodar
	
	OBS.: objetos referenciados indiretamente não são elegíveis ao GC
	
	
	
